\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage[margin=2.5cm]{geometry}
\usepackage{listings}

\title{OTP in Rust}
\author{Andreas Nicolaisen - \texttt{jtc313} \\ Marco Aslak Persson - \texttt{bfr555}}
\date{\today}

\begin{document}

% TODO: Actors vs. processes

\maketitle

\section{Introduction}

\section{Background \& Analysis}
\textit{What's OTP?}
\begin{itemize}
\item What is the goal of OTP?
\item What are the ``design principles'' of OTP?
\item How is it used?
\end{itemize}

\textit{How does this interact with Erlang}
\begin{itemize}
\item What parts of Erlang/BEAM is ``needed'' for implementing OTP? (processes,
  traps, mailboxes \& etc.)
\end{itemize}

\textit{Will probably have a similar structure to the Suture blog-post}
\begin{itemize}
\item What parts of OTP are we interested in porting.
\item How does this translate to Rust?
\item What does Rust make easier/harder?
\item What different things could an implementation focus on?
  \textit{Like performance, robustness, idiomaticity, expressiveness, ergonomics}.

  We'll try to find out whether it \textit{can} be done idiomaticly and ergonomically.

\item What have we chosen to focus on?
\end{itemize}

An implementation of an OTP-alike library will have to contain functionality in the lines of:
\begin{itemize}
\item \textbf{Message sending}\\
  The different actors should be able to communicate with each others, using
  messages. To accomplish this, they will need some way to refer to each other.
  This could be done by using global ids, registered names or passing around
  references to each other.
\item \textbf{Supervisor trees}\\
  In order to organize the program, the actors should be organized into
  supervisor trees. These will be trees of supervisor actors, with worker actors
  as leafes. The supervisors should be able to monitor and restart its children,
  should they crash, in accordance with supplied strategies and policies.
\item \textbf{Behaviours}
\end{itemize}

% TODO: Talk about local and global naming

\section{Design}
\begin{itemize}
\item Talk about what an OTP implementation overall consists of (in general)
\item Talk about our high-level design decisions
\item Talk about what design experiments we did (And explain why we went back on
  some of them)
\end{itemize}

We have decided to make our implementaion asynchronous, 
\begin{itemize}
\item \textbf{Message sending}\\
  We have opted to statically type messages. This means that each actor can only
  receive messages of its data type, as well as ``System messages''. Message
  sending is accomplished using ``Mailboxes''. Using these actors can
  send the 2 kinds of messages to each other. There 3 kinds of mailboxes,
  unnamed, named and dynamic. Unnamed mailboxes are the main kind of mailbox,
  which allows the actors to send system messages and data messages to each
  other. Should the receiving actor crash, trying to send a message to it, using
  an unnamed mailbox, will result in an error. Named mailboxes are an
  indirection over unnamed mailboxes, used for sending messages to an actor that
  is registered globally with a name. These 2 first kind of mailboxes are typed
  over the message type. The dynamic mailbox is mainly used in situations where
  multiple different actor types can occur. % TODO: Add example (which children)
  It can only be used for sending system messages, until the user tries to casts
  it to a concrete type. This allows the user to handle them without caring
  about the underlying message type.
\item \textbf{Actor naming}
  There are 2 forms of naming of actors, global and local. An actor's mailbox
  can be registered to a global name, then, through name-resolution, any actor
  can resolve the mailbox to that name. This useful for commucating with often
  used actors, without having to acquire its mailbox through other mean. Local
  naming is used when supervisors has to refer to its children. When actors are
  globally named, the name will be used locally as well. Not all actors have to
  be explicitly named, and when they're not they are given a unique local name.
\item \textbf{Supervision}
  Our design of supervision breaks into two parts, how the user specifies it and
  how they interact with it. We have chosen to use a declarative approch when
  specifying how supervision should be created, in order to aliviate the user
  from having to think about how supervision trees are built. Instead, they only
  have to think about how they want to structure their supervion
  tree/application. We allow the user to interact with the supervisors through
  messages, so that they can establish contact between actors dynamically. This
  is useful for dealing with dynamic instantiaion of actors, and for discovering
  other actors in the supervision tree, without having to resort to global
  naming.
  \begin{itemize}
  \item \textbf{Supervisor - Specification}
    In order to make it easier for the user, supervision trees can be created
    declaretivly, using a specication api. This consist of building blocks of
    supervisors and workers, which are put into a tree.
    % TODO: Insert example (diagram and code example)
    A supervisor will need some restart strategy, as well as vector of child
    specications. A worker will need some restart policy, and also takes an
    starting argument. Both supervisors and workers can be named, either locally
    or globally. Local names are only used when interacting with the supervisors
    of the named actor. % TODO: Add reasoning
  \item \textbf{Supervisor - Interaction}
    When interacting with a supervisor, it is important to note that supervisors
    themselves are actors, just like workers. This means that they can receive
    messages like any other actor. They can receive system messages asking them to
    shutdown, as well as requests. These requests allow other actors to ask for a
    list of the supervisors children, and to ask the supervisor to start another
    child, given a specification. All children are given a mailbox to their
    supervisor, so that they can make these requests of them.
  \end{itemize}
\item \textbf{Behaviours}
  The concept of behavious are implemented as traits, that should be implemented
  in order to fulfill the behaviour. This will consist of a number of methods
  that should be implemented, and they (the traits) will often over a type. They
  will often often with a helper methods that provides the common boiler plate
  functionality. When a message passed the the actor is not part of the boiler
  plate, the behaviour will pass this message unto implementation of the trait.
\item \textbf{Asynchronous exceptions} % TODO: Make name better
  Unlike in Erlang, actors can't kill each other directly. Instead each
  actors can request that an other actors shuts itself down. The handeling of
  this message will then take place in library code, to avoid usercode from
  simply ignoring the request.
\end{itemize}

\section{Implementation}
\begin{itemize}
\item Talk about some concrete implementation decisions (and what drove them)
\item Go into some (few) low-level technical details that might be interesting
\item Tokio, lightweight multiprocessing, like erlang.
\end{itemize}

\section{Examples}
\begin{itemize}
\item High-level architecture (with nice diagrams \texttt{:)})
\item Motivation, i.e. what does this example demonstrate
\item What does this example show/what can we observe/conclude from it
\end{itemize}

\section{Evaluation}
\begin{itemize}
\item What does idiomatic Rust look like? (2 parts, the implementation of OTP
  and the usage of our library)
\item How expressive is the library?
\item How easy is it to implement common patterns, in terms of ergonomics (code
  length, complexity, etc)?
\item How easy is it to understand written code?
\end{itemize}

\section{Conclusion}

\end{document}

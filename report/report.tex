\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage[margin=2.5cm]{geometry}
\usepackage{listings, listings-rust}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{hyperref}

\newcommand\figref[1]{Figure~\ref{#1}}

\title{OTP in Rust}
\author{Andreas Nicolaisen - \texttt{jtc313} \\ Marco Aslak Persson - \texttt{bfr555}}
\date{\today}

\begin{document}
\pagenumbering{roman}

\maketitle

\begin{center}
  \large{\bf Abstract}\\
  \vspace{0.5cm}
  \begin{minipage}[h]{0.6\linewidth}
    In this reportm we'll be describing our design and implementation of an actor
    model system inspired by Erlang/OTP, implemented in Rust. The focus of the
    library has been to port the core principles of OTP to Rust in a way
    idiomatic both to the actor model and Rust. We'll discuss our design
    decisions and the results of our experiments in form of an example
    application, which we've used to evaluate our library.
  \end{minipage}
\end{center}
\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Introduction}
In this report, we will present our implementation of an actor library in Rust,
inspired by Erlang/OTP. To do this we will start by introducing relevant
background on the actor model, and how Erlang and OTP works. We will analyze how
this can be implemented in Rust, and explain the areas where it is easy to get
similar behaviour, and also the areas where it will be difficult to implement
similar behaviour. We will then go into how we designed our library, explaining
our design goals and decisions. We will then explain how we implemented this
design, and what difficulties we encountered, and what decisions we made. Then
we have an example of how the library could be used, showcasing different parts
of the library. Finally, we will do an reflect on how the effort went, and
evaluate if we achieved our design goals.

\section{Background \& Analysis}
This section is partially inspired by Jeremy Bowers blog post on his
implementation of a actor library in Go\cite{SuturePost}.


\subsection{The actor model}
In the actor model, an application is structured around a collection of
independent actors. Generally, each actor has the following abilities:
\begin{itemize}
\item Each actor has the abilty to send messages to other actors, and
  themselves receive messages.
\item The actors can decide to take any action they desire based, on the messages
  they receive. This includes modifying some state that they hold on to, which
  can then be used when responding to later messages.
\item Each actor can spawn new actors.
\end{itemize}

\noindent
The actors exist as separate entities, and should not be able to affect each
other, unless it is through messaging each other. Typically, a lot of actors are
created, and each actor is tasked with handling small tasks.\\

\noindent
The message passing itself can be realized in two different ways, synchronous
and asynchronous. By synchronous, it is understood that when an actor sends
another actor a message, it will only continue its execution when the other
actor has received the message. By asynchronous, it is understood that the
message is sent much like a letter, in that once we have sent a message we don't
know when/if the other actor will receive it. In different realizations of the
actor model, there will be different guarantees as to whether messages will
always be received, or if they can be lost, as well as what order the messages
can be in. How the message passing works will also differ. All actors might have
some address that can be used to send them messages or be given names that can
change what they refer to, during the execution of the program.

\subsection{Erlang processes}
As mentioned, in an idiomatic actor model system, a lot of actors are often
created. This means that we can run the actors concurrently,
but we have to be careful about how we do it. If we were to, for example, run each actor on a
separate OS thread, we would encounter a large overhead each time a new actor
is created (as well as the cost of context switching). Erlang solves this by
providing lightweight processes, which are quick to create and only take up a
small amount of memory when created.\\

\noindent This allows us to use a new process for each actor that we want in our
system, without encountering a large overhead. Each process is equipped with a
\texttt{PID} (Process IDentifer). If a process (or actor) knows another's PID,
they can use it to send them messages, monitor it, as well as ``kill'' it.
Message sending is asynchronous, and anything can be sent. The other process can
then specify what it wants to receive at a given time, and how to act based upon
the messages it receives. By monitoring another process, the monitoring process
will be notified if the monitored process dies\footnote{Processes can also link
to each other, but that is beyond the scope if this project}. While this is not
part of the actor model, it is often quite useful. By sending a special signal,
a process can ``kill'' another process, which shutdowns the process, no matter
what it was currently doing. This is useful when organizing actors in
\textit{supervision trees}, which will be discussed in the next section.

\subsection{OTP}
Developing an application with Erlang is most often coupled with using OTP (Open
Telecom Platform). OTP is a platform consisting of a compiler, libraries,
middlewares, a database and some tools\cite{ErlangOTPDocs}. What we will be most
concerned with is supervision trees and behaviours.

\subsubsection{Supervision trees}
Supervision trees are a way to organize actors into supervisors and workers, in
a way that supports reliability. This is under the philosophy that parts of any
implementation will, from time to time, crash, and it should be set up to handle
it when it does. An example of a supervision tree can be seen in
\figref{fig:supervision_tree}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{./resources/SupervisionTree.png}
  \caption{An example of a supervision tree, the square nodes are supervisors,
    and the round nodes are workers.
    \href{https://erlang.org/doc/design_principles/des_princ.html}{Source}.}
  \label{fig:supervision_tree}
\end{figure}

\noindent
A supervisor will have a number of children, which can be both workers and other
supervisors. Should any of a supervisor's children shut down unexpectedly, the
supervisor has the responsibility of starting it back up again, if it is
specified that it should be restarted. Further, the children could have
interdependencies, so the supervisors can also restart other children than the ones
who shut down unexpectedly.

\subsubsection{Behaviours}
In an actor model system, many actors will often follow similar patterns. For
example, all of the supervisors in a tree will follow a similar pattern, some
actors will be simple servers, some will be state machines, etc. Knowing this,
OTP providers modules for a number of behaviours. These split the implementation
of the actor into two parts, the generic part and part specific to the actor. The
generic part is implemented in OTP, and the part specific to the actor is left
for the user to implement. This is done by implementing a set of callback
functions. These are used by the generic part of the behaviour, and is where the
user implements their part of the actor.

\subsection{How can this be implemented in Rust}
\begin{itemize}
\item \textbf{Immutability and actor isolation}\\
  In Erlang all data is immutable, and processes are isolated from each other.
  One of the main benefits of isolation, is to avoid shared mutable state, and
  the problems that arise from it. In Rust, different threads are not isolated from
  each other the same way that processes in Erlang are, and neither is all data
  immutable. However, Rust's type system prevents the danger of mutable shared
  state, both in single- and multi-threaded contexts, avoiding the common downsides
  of shared and mutable state. This means that the actors can affect other
  threads by ways other than message passing, however, the common downsides of
  this are avoided.
\item \textbf{Message passing}\\
  Unlike in Erlang, there are no intrinsics for sending and receiving messages
  in Rust. However, the standard library provides a multiple producer, single
  comsumer channel which fulfils this purpose. It will require some more code
  to create and handle these channels, but hopefully, this can all be done in the
  library itself, so that the experience of messaging other actors are largely
  the same as in Erlang.
\item \textbf{Monitoring and killing other processes}\\
  We have chosen to realize our actors as Tokio tasks (see design/implementation
  sections), which does not provide the same functionality as Erlang does for
  its processes.

  This means that we cannot simply monitor other actors the way we can in
  Erlang. We \textit{can} know when a task finishes, but only by awaiting its
  join-handle, which can only be done by one thread. This is becaused it cannot
  be cloned. This means that we need to implement some system for notifying
  other actors, of when an actor terminates, inorder to get the same monitoring
  functionality.

  We cannot kill other tasks the same way we can in Erlang, and this is one of
  the points where our library is going to differ from Erlang/OTP. This could
  theoretically be done if we were using OS threads, but for reasons discussed
  in the design section, we're not. Instead, we allow for asking another actor
  to terminate itself, by sending a message. These kinds of messages are
  prioritised over other kinds of messages, so it achieves close to the same
  semantics are Erlang, but not exactly.
\item \textbf{Behaviours}\\
  In Erlang/OTP, the way you use behaviours, is by implementing a set of callback
  functions, which are then called by the behaviour module. The way to do this in
  Rust is to implement a trait, with a series of methods, for a type. These
  accomplish the same thing, using different language features.
\end{itemize}

\section{Design}
\subsection{Design goals}
In the design of our library, we have set the following goals:
\begin{itemize}
\item Implement an OTP-like (or rather, a subset of it) system in Rust in a way
  that is idiomatic to Rust.
\item Strongly type the messages that the actors will pass to each other.
\item Allow the user to write idiomatic actor model code, in a way that is also
  idiomatic to Rust.
\item Enable the user to easily organize their actors in supervision trees, both
  in a declarative as well as dynamic fashion.
\item Make it easy for the user to implement common patterns, without having to
  worry about how the actors interact with the supervision tree.
\end{itemize}

\noindent
Overall, the aim is to create a library that provides better type-safety than
what is experienced in Erlang, without making it harder to implement an
application. This should be accomplished by using Rust's own guarantees, so that
a programmer experienced with Rust can use it, without a large barrier to entry.

\subsection{Design details}
We've designed our library to be implemented with an asynchronous execution
model. This allows us to easily achieve concurrency between the actors, in both
single and multi-threaded contexts. It is not necessarily a requirement for
actors to run in parallel. By making our library asynchronous we enable the
implementation to take advantage of cooperative multi-threading via ``green
threads'', which can both work in single-threaded and multi-threaded contexts.
Green threads are a more light-weight alternative to using operating system
threads, which is important because idiomatic use of the actor model often
involves creating actors for even small tasks. If creating an actor required
starting an operating system thread, then the overhead would be quite significant
compared to green threads.\\

% What is actor?
\noindent
Actors in our library are realized as isolated computations % ?: Word choice
which receive and act upon messages sent to them through their mailboxes.\\

\noindent
Mailboxes are objects that enable the sending of messages to an actor, and are
comparable to PIDs in Erlang. We've opted to not hide mailboxes behind an
indirection, like a PID, and instead make actors use and store the
data-structure required for the actual sending of messages directly. This is done
to avoid having to do extra book-keeping (like maintaining a --- possibly global
--- map of PID to the data-structure required for sending messages). This is at
the cost of having to possibly store more data per mailbox compared to PID, as
well as having to clone the mailbox whenever it needs to be sent to another
actor (which is required due to Rust's ownership system).\\

\noindent
All actors can receive two kinds of messages. The first being system messages
which pertain to system-level concerns. Currently, this only involves requesting
an actor to shut down. In addition to system messages, actors can also
receive messages of their own specific message type. The message type of an
actor is specified as part of the actor's implementation. The only requirement
for an actor's message type is that it's transferable between threads, i.e. it
implements/satisfies the \texttt{Send} trait in Rust. This requirement allows
actors to run on separate threads. Though by only having this requirement, we do
not have the required invariants to allow for inter-process or remote
communication between actors, since that would require that messages were also
serializable. The reason we choose to have the system messages as a separate
thing, is to make it easier to deal with actors of different types, in contexts
where their type is irrelevant (such as in the supervisor implementation). In
hindsight, this is properly an unnecessary complication, since all messages
could be wrapped in some sort of an \texttt{Either<SystemMessage, MessageType>},
or \texttt{SystemMessage} could have another variant containing the actor's
message type. This would require more conversion in the background, but from the
users perspective, it would probably be easier to use, and we wouldn't have to
store/use two channels for each mailbox. On the other hand, having the two kinds
of messages in separate channels, makes it easier to prioritise system message,
without having to go through all pending messages.\\

\noindent
Actors are responsible for acting upon the messages they receive. This is mainly
intended to be done through behaviours which in our library is the equivalent
concept as in OTP. In our library behaviours are realized as different traits
with methods for the user to implement their own business logic and usually a
helper function for starting actors implementing that behaviour.\\

\noindent
Given this context, we will explain our design of different parts, in more
specific terms:
\begin{itemize}
\item \textbf{Mailboxes}\\
  There are three kinds of mailboxes, unnamed, named and dynamic. Unnamed mailboxes are
  the main kind of mailbox, which allows the actors to send system messages and
  data messages to each other. Should the receiving actor crash, trying to send
  a message to it, using an unnamed mailbox, will result in an error. Named
  mailboxes are an indirection over unnamed mailboxes, used for sending messages
  to an actor that is registered globally with a name. These two first kinds of
  mailboxes are typed over the message type. The dynamic mailbox is mainly used
  in situations where multiple different actor types can occur, such as when
  getting a list of a supervisor's children. It can only be used for sending
  system messages, until the user tries to casts it to a concrete type. This
  allows the user to handle them without caring about the underlying message
  type.
\item \textbf{Actor naming}\\
  There are two forms of naming of actors, global and local, both given before
  the actor is started. The names are used for two different purposes, for
  differentiating between actors locally, and for acquiring a reference to an actor.
  An actor can ask a supervirsor (usually its own) for a list of its children.
  The supervisor then replies with a list of its children, consisting of the
  children's names, and the children's mailboxes. These names will be the names
  that were given before the child was started (either global or local). If a
  child is not given a name, it will be assigned one by its supervisor. If a
  child is  globally named, it will additionally have its mailbox globally
  registered by  its supervisor on startup. This global registration is useful
  for communicating with often used actors, without having to acquire a reference
  to its mailbox through other means. This is how the named mailboxes work.
\item \textbf{Supervision}\\
  Our design of supervision breaks into two parts, how the user specifies it and
  how they interact with it. We have chosen to use a declarative approach when
  specifying how a supervision tree should be created, in order to alleviate the
  user from having to think about how supervision trees are built. Instead, they
  only have to think about how they want to structure their supervision
  tree/application. We allow the user to interact with the supervisors through
  messages, so that they can establish contact between actors dynamically. This
  is useful for dealing with dynamic instantiation of actors, and for discovering
  other actors in the supervision tree, without having to resort to global
  naming.
  \begin{itemize}
  \item \textbf{Supervisor - Specification}\\
    In order to make it easier for the user, supervision trees can be created
    declaratively, using a specification API. This consist of building blocks of
    supervisors and workers, which are put into a tree.
    A supervisor will need some restart strategy, as well as a list of child
    specifications. A worker will need some restart policy, and also takes a
    starting argument. Both supervisors and workers can be named, either locally
    or globally.
  \item \textbf{Supervisor - Interaction}\\
    When interacting with a supervisor, it is important to note that supervisors
    themselves are actors, just like workers. This means that they can receive
    messages like any other actor. They can receive system messages asking them to
    shut down, as well as requests. These requests allow other actors to ask for a
    list of the supervisor's children, to ask the supervisor to start another
    child with given a specification, and allows for monitoring children i.e.
    being notified whenever a child is shut down or restarted. All children are
    given a mailbox to their supervisor, so that they can make these requests of
    them.
  \end{itemize}
\item \textbf{Behaviours}\\
  The concept of behaviours from OTP are implemented as traits, that should be
  implemented in order to fulfil the behaviour. This will consist of a number
  of methods that should be implemented, and they (the traits) will often be
  over a type. They will come with a helper method that provides the common
  boilerplate functionality (eg. the handling of system messages). This
  method serves the same purpose as the behaviour module in Erlang. When a
  message passed to the actor is not part of the boilerplate, the behaviour
  will pass this message onto the implementation of the trait.
\item \textbf{Asynchronous exceptions}\\
  Unlike in Erlang, actors can't kill each other directly. Instead, each
  actor can request that another actor shuts itself down. The handling of
  this message will then take place in library code, to avoid user code from
  simply ignoring the request. Since the messages are handled sequentially this
  means that actors cannot be shut down when they are handling other
  messages. This has the advantage of avoiding actors being shutdown in critical
  sections but has the disadvantage of not being able to shut down an actor that
  is stuck. This is the only practical way of shutting down an actor, since it
  is not possible to stop a scheduled task. One way of shutting down a running
  actor \textit{could} be done, it to have each actor be its own separate OS
  thread, which you could then ask the OS to shut down. The comes with the
  downside mentioned earlier, of not being able to take advantage of ``green
  threads''.
\end{itemize}

\section{Implementation}
We have chosen to base our implementation on the Tokio library. Tokio provides an
asynchronous execution runtime, with support for \texttt{Task}s, which are
light-weight non-blocking execution units. This is especially useful because we
want the overhead of spawning actors to be low.

Actors are concretely realized in our library as a Tokio \texttt{Task}, with the
receiving end of its mailbox, which act upon messages sent to it.

\begin{itemize}
\item{\bf Mailboxes} \\
Mailboxes are implemented as an abstraction on top of channels. Channels as a
concept are both found in the Rust standard library, and in Tokio, and they are a
mechanism for sending values between threads via a FIFO queue. Specifically, we
use the multi-producer, single-consumer (\texttt{mpsc}) kind. Such a channel
consists of a unique \texttt{Receiver}-end and any number of \texttt{Sender}s.
The actor owns the \texttt{Receiver} end and uses it to accept incoming
messages, while the \texttt{Sender}s are abstracted over as mailboxes. Normally
it is the responsibility of the library part of the behaviour, to handle the
actual reception of messages. Therefore, the receiver is normally exposed to the
behaviour implementer.
% - Boundedness
Tokio
provides two kinds of \texttt{mpsc} channel, bounded and unbounded. Sending
never blocks for unbounded channels, while bounded ones can only hold a
specified amount of unhandled messages. We've chosen to use bounded channels
with a capacity of 512 for our mailbox implementation. While we want message
sending to be asynchronous --- which unbounded always provide, and bounded only
does until their capacity is reached --- we've still opted for bounded channels
with a high capacity because it makes dealing with runway situation easier.
Instead of simply endlessly sending messages into to the ever-growing queue,
which could eventually hog all the device's memory, the sender is instead
(temporarily) blocked or deadlocked, which is easier to debug than a runaway
resource-consuming program.
% - bounded debugability
This choice has mainly been a development practicality choice and were we to
further develop this library, we would allow the user to specify whether they
want their mailboxes to be bounded or unbounded, and in the former case with
what capacity. This should be a relatively easy extension since the actual
choice of channel is hidden behind our mailbox abstraction.

As mentioned in the design section we have a couple of different types of
mailboxes. First of all, we have a mailbox trait (called \texttt{Mailbox}) which
allows for code be generically parametric over which specific type of mailbox it
deals with. The mailbox trait supports sending messages of the associated
message type and querying whether the mailbox has been closed. The most commonly
used mailbox type is the \texttt{UnnamedMailbox}, which simply behaves as an
abstraction over the underlying channel. The \texttt{NamedMailbox} extends the
unnamed variety with a naming indirection. While an unnamed mailbox can only be
acquired by cloning or being sent one, a named one can be acquired by resolving
a name. A global registry is maintained, mapping names to mailboxes. Operations
on a named mailbox only succeed if the name can be
resolved. If the underlying channel of the named mailbox has been closed, upon
trying to send a message via the mailbox, an attempt is made to re-resolve the name to a
mailbox of the same type. This re-resolution is done to allow for seamless
communication with a globally named actor that might have been restarted.

So far the mailboxes we've seen are parameterized over their message type. But in
some cases, we want to store mailboxes of different message types together.
Examples of such heterogeneous collections of mailboxes are the globally named
mailbox registry and supervisors' lists of children. In both cases, neither of
those perform any operations on the mailboxes that involve their message type.
In order to allow for heterogeneous storage of mailboxes, we've implemented the
\texttt{DynamicMailbox} type. It is a non-parametric mailbox which only supports
operations not involving the underlying mailbox's message type, and a method for
attempting to convert it back into a typed mailbox (which might fail if the
underlying message type doesn't match the attempted type). This means that it's
impossible to send messages of the wrong type.
It's implemented by
storing type-information about the underlying mailbox at runtime in our
\texttt{AnyBox} type, which stores the underlying mailbox in an (owned) separate
allocation, such that the layout of the \texttt{AnyBox} is homogenous, and
thereby making \texttt{DynamicMailbox}es homogenous too.
This introduces a runtime overhead on
all operations on the dynamic mailbox, but since the most common operation on
mailboxes is sending typed messages, which only can be done by converting the
dynamic mailbox into an unnamed one, this is not a big performance concern,
since that should be a relatively one-off thing in any given scenario.

\item{\bf Supervisors} \\
Supervisor trees are specified using the \texttt{SupervisorSpec} and
\texttt{ChildSpec} data-structures. \\ The \texttt{SupervisorSpec} contains the
supervisor's restart strategy (one-for-one, one-for-all or rest-for-one) and a
list of \texttt{ChildSpec}s. \texttt{ChildSpec}s contain the child's restart
policy (permanent, transient or temporary), its global or local name if any,
its type and initialization argument. \texttt{ChildSpec}s can only be
constructed using the \texttt{child} function, which is parameterized over a type
implementing the \texttt{Actor} trait and takes the policy and starting
argument. The \texttt{Actor} trait is probably poorly named since you can have
actors that don't implement it. What the \texttt{Actor} trait is responsible for
is associating a message- and argument-type with a given struct and requiring
the implementor to define a \texttt{start} method, which takes in an
initialization argument and a mailbox to the supervisor of the actor being
started (if one is present). It returns a mailbox to the newly started actor,
together with a \texttt{JoinHandle} which is the unique token used to await the
completion of the actor's task. The \texttt{child} function then fills in the
required information about the actor's type, which allows for heterogeneous
storage of different actors in the same array of \texttt{ChildSpecs} using the
same mechanism \texttt{DynamicMailbox} uses. The \texttt{ChildSpec} can then be
further annotated with either a local or global name using the \texttt{named} and
\texttt{globally\_named} methods respectively.

This technique allows us to declaratively specify a heterogeneous supervision
tree as long as all the actors in it implement the \texttt{Actor} trait.
Supervisors themselves also implement this trait, and their argument type is
their \texttt{SupervisorSpec}. When a supervisor is started, it then calls each
child's start method with their specified start argument. If supervisors are
nested, this results in a recursive depth-first initialization of the
supervisor-tree.

In a previous iteration of our supervisor implementation, we experimented with
using a single closure that had all the same responsibilities as the current
\texttt{ChildSpec}. It would take no arguments, instead possibly capturing any
arguments used for initialization. It would then be expected to
initialize, start, register the name of the actor (if any) and return the
mailbox, join-handle and restart-policy to the supervisor calling. This turned
out to be very cumbersome and prone causing type- and life-time errors due to
the nature of closures in Rust. So we instead opted for the more data-structure
oriented design, and delegated the initialization part to a more fixed scheme
described above instead of the completely free-form closure design. This not
only made specifying supervisor trees technically easier, it also made the
specifications much more readable.

The supervisor actor is implemented as an actor that handles
requests for operations like listing children, starting new children and
allowing other actors to be notified of child restarts and shuts down (we call it
monitoring). In addition to these external messages, supervisor actors also
await notifications about the shutdown of their children via the
\texttt{JoinHandle}. Whenever such a notification is received, it inspects
whether the shutdown was due to a panic or because the task ran to completion,
and then decides what sort of restart action (if any) it should take based on
its own restart strategy and the child's restart policy. Supervisors need to
await both incoming messages as well as join-handles at the same time, to handle
whichever comes first. Tokio has a \texttt{select!} operation that allows for
doing such a thing, but it does not allow for awaiting a dynamic amount of
join-handles (or any future for that manner) this way. In order to work
around this limitation, we start a task when starting a new child, whose only
job is to await on that child's join-handle and send the result to the
supervisor over a private channel. Then the supervisor only has to listen on a
single receiver on its own end, while many of these tasks can send their join
notifications to it.

The supervisor also keeps track of a list of ``monitors'' for each child. When a
child is shut down or restarted, all (if any) of said child's monitors are
notified about this. When notifying about a restart, the child's new mailbox is
also sent along. A monitor is simply the \texttt{Sender} end of an \texttt{mpsc}
channel, over which \texttt{MonitorMessage}s are sent. Shutdown notifications
are only sent when a child shuts down and isn't restarted. The channel is
always closed after a shutdown message has been sent. Monitors are registered
by sending the supervisor a monitor message using the \texttt{monitor} function,
which consists of the local-id of the child to be monitored and the
\texttt{Sender} to send the notification with.

We have not implemented the logic for shutting down the supervisor if too many
restarts occur in a short (user-specified timespan). This behaviour is found in
OTP and ensures that supervisors don't get stuck in restart loops when the
problem should be dealt with at a higher level. We have not implemented this due
to time constraints.

\item {\bf The request-handler behaviour} \\
  This behaviour is comparable to OTP's \texttt{gen\_server}, it allows for
  defining actors that handle requests, allowing for an immediate- or delayed
  response. The user-defined part of the behaviour is facilitated by the
  \texttt{RequestHandler} trait, which consists of two type-parameters, the
  request and response types, and two methods \texttt{init} and
  \texttt{on\_request}. The \texttt{init} method is called as the first thing
  when the request-handler's task has been spawned. Its mailbox is passed along
  in order to allow the request-handler to know its own mailbox, and possibly
  send it to other actors. The \texttt{on\_request} methods takes the
  request-message, a unique request-id and a deferred reply channel. It returns
  either a \texttt{Response::Reply} with the reply value or
  \texttt{Response::NoReply}. If \texttt{on\_request} returns with a reply,
  said reply is directly sent back to the requester. If no response is returned
  by the request-handler then the reply is deferred by storing requests in a map
  using the request-id. In order to reply to a deferred request, the request-id
  together with the reply-value should be sent over the deferred-reply channel.
  By using a channel for deferred replies instead of a call-back, queue or just
  exposing the deferred-reply map, we enable the possibility of passing the
  sender for that channel on to another actor, allowing request handlers to
  delegate the reply to someone else.

  The mechanism used for allowing requesters to get a reply back is by bundling
  their actual request-message together with the sender-end of a
  oneshot-channel. A oneshot-channel is a channel like \texttt{mpsc}, but which
  can only transfer a single value. Then the request-handler can send its
  response over the sender passed along with the request. The requester then
  receives the reply by awaiting a reply on the receiving end. This is done because
  it requires as little coupling as possible, the requester can pass on the
  receiving end onto any other actor that might wish to receive the value, and
  the request-handler can delegate the reply to any other actor as explained
  earlier. There is no need to communicate a mailbox for the request-handler to
  reply back to, which in itself would introduce challenges, since what message
  should the request-handler even reply with? That would require further
  specification. While it is possible, and might even be preferable in some
  cases, this solution makes the fewest assumptions and is therefore the most
  flexible.

\end{itemize}
\section{Example Application}
During our design and implementation process, we've used an example application
to both guide and evaluate our design and implementation. The example is
inspired by an example in Learn you some Erlang\cite{LYSE}, but it is not
exactly the same. A diagram of this can be seen in \figref{fig:example_diagram}.
We've included the full implementation of this example application in the appendix.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{./resources/PoolDiagram.pdf}
  \caption{Diagram of our example programs' supervisor tree}
  \label{fig:example_diagram}
\end{figure}

\begin{wrapfigure}{r}{0.4\textwidth}
\begin{lstlisting}[language=Rust,basicstyle=\footnotesize]
supervise(
  RestartStrategy::OneForAll,
  vec![
    child::<PoolServActor>
      (RestartPolicy::Permanent, ())
      .globally_named(POOL_SERV_NAME),
    supervisor(
      RestartPolicy::Permanent,
      RestartStrategy::OneForOne,
      vec![
        child::<PoolWorkerActor>
         (RestartPolicy::Permanent, ())
        ; num_workers
      ],
    ).named(POOL_SUP_NAME),
  ],
)
\end{lstlisting}
  \caption{Supervision tree specification for the example}
  \label{fig:ex-spec}
\end{wrapfigure}

\noindent
The example is of a worker pool. The idea is that work can be submitted to a
pool-server, which then delegates the work to a worker from a pool of workers.
The pool of workers are all transient children of the pool supervisor which
operates using a one-for-one strategy, restarting any worker that crashes. The
pool-server actor and the pool-supervisor are in turn supervised under a common
supervisor. This supervisor uses the one-for-all strategy, restarting both the
pool-server and the pool-supervisor if either crashes. The specification can be
seen in \figref{fig:ex-spec}.\\

\noindent
We have chosen this example because it is a simplified (but non-trivial) example
of a realistic application. It exercises the following aspects of our
implementation:
\begin{itemize}
\item A supervisor tree with nested supervisors.
\item Supervisor interaction. The pool-server actor queries the supervisors in order
  to monitor and acquire the mailboxes of the worker actors.
\item Communication between actors. The pool-server actor sends work to the
  worker actors, and the workers reply back with the results, which the
  pool-server actor then returns to whoever submitted the work.
\end{itemize}

\noindent
The pool-server implementation (\texttt{PoolServActor}) is an instance of the
\texttt{RequestHandler} behaviour. Its message type is
\texttt{PoolServMessage}.\\

\noindent
Upon being started (i.e. when its \texttt{init} method
is called), the pool-server actor first asks its supervisor for a list of its
children (Using \texttt{which\_children}). It then finds the child with the
local name of its sibling (the pool-supervisor), and thereby gets its mailbox.
Then it queries the pool-supervisor for all its children and monitors them all.
Then it spawns a task for each child that receives monitor messages and sends a
message to the pool-server's mailbox with the monitor result (whether the child
has shut down or restarted) via the \texttt{{PoolServMessage::WorkerMonitor}}
message. This allows monitor messages to be handled under the pool-server's
\texttt{handle\_request} method.\\

\noindent
When a piece of work is requested to be executed, the pool-server is sent a
\texttt{PoolServMessage::Start} containing the work item. It then forwards the
work item to a worker actor. Which worker actor is decided based on a
round-robin scheme. A task is then spawned that awaits the reply from the
worker, and forwards it to the pool-server via the
\texttt{PoolServMessage::Result} message. When the pool-server receives a result
it then uses the request-id associated with the result to reply with the result
to the sender of the work request. If a worker crashes, it will be restarted by
the pool-supervisor. The pool-server will then be notified of the restart and
will update the mailbox of the corresponding worker, to the one of the new
worker. If the pool-server is notified that a worker has been shut down, this
indicates that the pool-supervisor is being shutdown or restarted. Therefore the
worker pool is unavailable, and the pool-server can't continue operating and
therefore panics. Since the pool-server is ``Tied`` to the pool-supervisor (due to
the one-for-all restart strategy), it would have been restarted anyway.\\

\noindent
By delegating the reception of the result from the worker, the pool-server can
avoid blocking in the request handler while waiting for the result. This allows
it to handle other messages while the work is completed by a worker. It would
also be possible --- instead of awaiting a reply from the worker --- to make the
worker send the result as a message to the pool-server actor instead (acquiring
the pool-servers mailbox through name resolution, since it's globally named).
We've not opted to do that in this example, even though it's a very valid way of
implementing it. The reason is that since workers are also instances of the
\texttt{RequestHandler} trait, a oneshot channel is created for the request's
reply anyway, so we opted to use that. As mentioned in the implementation
chapter, we could also extend the \texttt{RequestHandler} to handle requests
that don't expect a reply, and in that case, the alternative design would make
even more sense.\\

\noindent
The worker actors (\texttt{PoolWorkerActor}) are very simple instances of the
\texttt{RequestHandler} behaviour. They have no state and only handles one
message; the work item message, which consists of the work data and a
request-id. Upon receiving a work-item the worker simply performs the work and
immediately replies back with the result.\\

\noindent
In this example, work items are just a list of integers, and the result is the
sum of those integers, but that is not very important for this example.

% What purpose does our example serve?
% - Supervisor trees, supervisor querying, interactor communication
%


\section{Evaluation}
In this section, we will evaluate different parts of our design/implementation,
wrt. different design goals.

\subsection{Idiomaticness}

\begin{itemize}
\item {\bf Types and constraints} \\
A part of idiomatic Rust is encoding constraints and communicating
semantics using the type-system. For example, using Rust's ownership and
uniqueness semantics to enforce the uniqueness of a resource and using enums
like \texttt{Size::Large}/\texttt{Size::Small} instead of using a boolean
argument like \texttt{is\_large: bool}. We generally only impose the strictly
necessary constraints. We've tried to write our implementation such that as few
type-constraints as possible are required from the user. In an earlier
iteration --- due to some implementation details concerning storage of mailboxes
--- we introduced a requirement for messages not only to be \texttt{Send}
(meaning they're safe to transfer between threads), but also \texttt{Sync}
(meaning that it is safe to share references of it between threads). We later
discovered that we could do away with this constraint, which allows the user to
for example to send data-structures with internal mutability. Other than in a few
internal cases where an enum would be preferable to a boolean argument, the only
obvious missed opportunity for encoding constraints in the type-system is the
case of \texttt{RequestId}s. As detailed in the implementation section, the
request-handler behaviour uses request-ids for identifying requests that have
deferred replies. Currently, they're simply an opaque copy-type (i.e. just data),
and it is therefore possible to attempt to reply with the same request-id
multiple times. Since requests can at most have one reply, this can potentially
cause a panic at runtime. We could enforce the reply-at-most-once nature of
requests via the request-id type, by making it an unclonable type and consuming
it when it's used for a reply. Thereby we've made it impossible to reply twice
to the same message\footnote{Technically it's still possible if we generate the
  same request-id twice, but since we use random UUIDs, the chance of a
  collision is {\bf very} small.}.

\item {\bf Safety} \\
Idiomatic Rust also highly values safety (this is one of Rust's design goals after
all). But this is usually not as much of a conscious choice for Rust code as in
other system-languages, this is mainly due to the fact that Rust's safety
(both memory- and thread-safety) originates from its type-system and is exercised
through its standard library. Because of this, in most cases if one's code
doesn't use \texttt{unsafe} and compiles, it should be memory- and thread-safe
(assuming the libraries used are safe). But in idiomatic Rust, if unsafe code is
necessary, then it should be limited to the places where it is strictly
required, and a safe abstraction should be built on top of it. This is how large
parts of Rust's standard library is implemented. The vast majority of our code
does indeed not use unsafe code, and all our unsafe code is contained inside of
our \texttt{AnyBox} abstraction.

\item {\bf Errors} \\
Rust's error model divides program errors into two categories, recoverable errors
and unrecoverable errors. The former is realized via the type-system, often as
\texttt{Result} types, which encodes both the value to be returned given a
successful computation, as well as the error to be returned if something goes
wrong. The user of that result has to inspect which one it was and
take appropriate action. The latter is realized as panics, which stops the
current thread completely and tries to safely unwind the stack. Panicking is
mainly used when some invariant has been broken or something outside the
program's control has gone unrecoverably wrong (like running out of memory).
What will be deemed a recoverable error will differ greatly from case to case:
if I am a kernel module, then running out memory probably shouldn't bring the
entire operating system down, instead I might wish to shut down processes, or try
to swap memory to disk, while if I am a simple command-line tool, I am probably
not going to deal with running out of memory. Therefore it often shouldn't be
the library making the call of whether an error is recoverable or
not, and should therefore most of the time be returning result types.
The exception to this is of-course if the error that has occurred is some
library-internal invariant that has been violated. Our library implementation
follows this way of handling errors, only panicking when internal invariants
have been broken and otherwise exposing error-types to the user. User-code using
our library on the other hand is a different story. Since our library intends to
help built robust applications that can handle failures of actors via supervision
trees, the tolerance for when to panic is lower in user-code, since recovery of
panics is a core part of the supervisor-tree concept. This usually manifests
itself as user-code not handling error cases for operations that are expected to
succeed and instead panicking. This for example can be seen in our example
application, where assumptions about the supervision tree structure are a part of
the pool-server's implementation, and any assumption invalidated will cause it
to panic. This will in turn cause the pool-server and pool-supervisor (and
thereby all the pool workers) to be restarted, with the goal of restoring the
tree-structure to the expected form.

\end{itemize}

\subsection{Expressivity}

The question of expressivity can be split into two parts. The first part being,
``what can be expressed?'' and the second being ``how easy is it to express
certain things?''. For the question of what can be expressed, we've already
mentioned that we've attempted to keep constraints down to a minimum. Of course,
Rust as a language disallows many things that a language like C wouldn't stop
you from doing, by virtue of its strict type-system. First of all, our library
doesn't require the user to follow a strict way of doing things (one might argue
that in that case, it would be a framework, not a library). This means that the
user is free to only partially use our library, for example together with a more
traditional system, or they can structure their entire application using it if
they like. The user is able to build their own actors- and behaviour-types if their
needs are not met by the ones in place. One specific thing that is currently not
possible to do, due to our library design, is communicating ``up''
the tree, further than your own supervisor. For example, there's no way, as an
actor, to access your supervisor's
supervisor, unless it's globally named, or another actor sends you its mailbox.
There's nothing architectural about this limitation, and indeed our API allows
for this to be implemented easily since the \texttt{start} method takes in an
optional supervisor-mailbox. So extending supervisors to allow for querying of
their parent-supervisor would be easy to add. Also, in our design it is not
possible to create circular supervision structures, nor is it possible to have
multiple supervisors for a single child. This is due to the fact that the
\texttt{JoinHandle} which supervisors use for keeping tabs on their children is
unclonable and is never leaked outside the supervisor, which also means that a
child can't be adopted by another supervisor.\\

\noindent
As for the ``how easy is it to express certain things'' question, we'd argue
that many things commonly done in the actor model are easy to express.

\begin{itemize}
\item {\bf Defining actors:} Defining
actors usually requires implementing two interfaces, first the trait of desired
behaviour to implement (defining how your actor behaves), as well as the
\texttt{Actor} trait for starting your actor (allowing it to be started from a
supervisor). A behaviour like \texttt{RequestHandler} abstracts away most of the
details of running an actor, and leaves the user simply to specify how it acts
on- and replies to messages. Implementing the \texttt{Actor} trait usually boils
down to passing the given argument to the constructor of your actor type and
calling your behaviour's start function.
\item {\bf Actor communication:} The fundamental way of communicating in the
  actor model is by sending messages. Sending messages in our library simply
  requires having the mailbox of the recipient and the message you want to send.
  It is impossible to send the wrong kind of message. % More?
\item {\bf Supervision trees: } Supervision trees can be defined in a terse and
  declarative manner using \texttt{SupervisorSpec} and
  \texttt{ChildSpec}s. They can be treated as data-structures, allowing for
  dynamic declarations. In addition to using declarative specifications, dynamic
  supervision is also possible via the supervisor API, which simply requires
  the supervisor's mailbox to use.

  Where the expressiveness of our library is lacking is in the navigation of
  supervision trees. Since the only way to query a supervisor is by using
  \texttt{which\_children}, which returns data from all the children of the
  supervisor, it can become quite verbose. For example, to find a specific
  sibling by local id, one has to do quite a lot of unpacking, as can be seen in
  \figref{fig:sibling} from \texttt{PoolServActor}'s \texttt{init} method. Going
  further down the supervision tree requires further queries of this kind, which
  will become quite verbose.

  \begin{figure}[h]
    \centering
    \begin{minipage}[h]{0.4\linewidth}
\begin{lstlisting}[language=Rust,basicstyle=\footnotesize]
// Get the pool supervisor
let mut pool_sup =
  which_children(&mut self.supervisor)
    .await
    .unwrap()
    .into_iter()
    .find(|ch|
      ch.local_id ==
       LocalId::Named(POOL_SUP_NAME.to_string()))
    .unwrap()
    .mailbox
    .into_typed::<SupervisorRequest>()
    .unwrap();
\end{lstlisting}
    \end{minipage}
    \caption{How \texttt{PoolServActor} acquires its sibling's mailbox, the pool-supervisor}
    \label{fig:sibling}
  \end{figure}
These kinds of operations might be relatively common if one wishes to avoid
global naming of actors. It would therefore help our library's expressivity if
we added helper functions for navigating the supervision tree in such a targeted
manner. As it stands, this kind of friction makes it more tempting to globally name
actors and supervisors, possibly with dynamic names, which we consider a bad
thing. Ideally, a library should make doing the ``right thing'' easier than doing
the wrong thing. This is luckily not as much an architectual problem but instead
due to us not having defined helper functions for these kinds of operations.
\end{itemize}

\noindent
A pattern that has fallen out of our design is what we've
called the ``adapter task'' pattern. It is where an actor is waiting for something to
be sent over a channel, usually a \texttt{oneshot} channel, and in order to
handle the reception of it, it spawns a new task whose sole responsibility is to
receive the value, and forward it to the actor's mailbox as a specific message
containing the result. For example, this happens in the \texttt{PoolServActor} when
both handling monitor messages and when awaiting the results from a worker. As
described in the implementation section, raw channels are used for replying to
requests because it makes the fewest assumptions. But often an actor wants to
deal with this kind of reply the same way it deals with normal messages. This
``adaptor task'' pattern makes code harder to read. The intent: ``I want to receive the result from this channel as this kind of
message'', is cluttered with the details of spawning tasks, cloning mailboxes, receiving the
value, converting it to the message type, and then sending it to its own mailbox.\\

\noindent
If we were to deal with this, there could be two approaches. Either we could
embrace this pattern, and add helper functions that generalizes this it, or
we should re-design our reply-back method. A possible redesign could be to use
the type-system to create a more generic approach to receiving messages. For
example, instead of passing the sender-part of a \texttt{oneshot} channel,
one could pass dynamic trait object, of a trait that abstracts over what can be
sent such reply. This could still be a \texttt{oneshot::Sender}, but it could
also be a mailbox of a message type that the reply can be converted into.

\subsection{Final evaluation thoughts}
All in all, our implementation provides all of the necessary building blocks for
building actor model systems. We ensure the amount type-safety we set out to
get, while not making it unnecessarily restrictive. It is fairly easy to set up
supervision trees, while still allowing the user to add to its layout
dynamically. Some areas are harder to use than necessary, but this
might be improved if we added some helper functions. We could also introduce
some type constraints, which would give stronger invariants, and prevent
possible panics at runtime. Our library is expressive enough that a user can
implement actor model systems, without allowing for things such as circular
supervision ``trees''.

\section{Conclusion}
In conclusion, in this report, we have detailed our implementation of an OTP-like
actor library in Rust. We have laid out the relevant background and
compared/analyzed how the two languages enable building actor model systems. We presented
our design goals and explained the design choices we took accordingly. We have
explained how we implemented our library, according to these goals/decisions. We
have presented an example of how our library could be used, with an example
application. Using the material laid out in the implementation and example, we
have evaluated our results, relative to the design goals we presented and
judged how well our implementation accomplishes these goals.

\newpage
\bibliographystyle{plain}
\bibliography{report}

\section{Appendix - Example Application - \texttt{pool.rs}}
\lstinputlisting[language=Rust, basicstyle=\footnotesize, numbers=left]{../oir/src/examples/pool.rs}

\end{document}

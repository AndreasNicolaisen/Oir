\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage[margin=2.5cm]{geometry}
\usepackage{listings}

\title{OTP in Rust}
\author{Andreas Nicolaisen - \texttt{jtc313} \\ Marco Aslak Persson - \texttt{bfr555}}
\date{\today}

\begin{document}

% TODO: Actors vs. processes

\maketitle

\section{Introduction}

\section{Background \& Analysis}
\textit{What's OTP?}
\begin{itemize}
\item What is the goal of OTP?
\item What are the ``design principles'' of OTP?
\item How is it used?
\end{itemize}

\textit{How does this interact with Erlang}
\begin{itemize}
\item What parts of Erlang/BEAM is ``needed'' for implementing OTP? (processes,
  traps, mailboxes \& etc.)
\end{itemize}

\textit{Will probably have a similar structure to the Suture blog-post}
\begin{itemize}
\item What parts of OTP are we interested in porting.
\item How does this translate to Rust?
\item What does Rust make easier/harder?
\item What different things could an implementation focus on?
  \textit{Like performance, robustness, idiomaticity, expressiveness, ergonomics}.

  We'll try to find out whether it \textit{can} be done idiomaticly and ergonomically.

\item What have we chosen to focus on?
\end{itemize}

An implementation of an OTP-alike library will have to contain functionality in the lines of:
\begin{itemize}
\item \textbf{Message sending}\\
  The different actors should be able to communicate with each others, using
  messages. To accomplish this, they will need some way to refer to each other.
  This could be done by using global ids, registered names or passing around
  references to each other.
\item \textbf{Supervisor trees}\\
  In order to organize the program, the actors should be organized into
  supervisor trees. These will be trees of supervisor actors, with worker actors
  as leafes. The supervisors should be able to monitor and restart its children,
  should they crash, in accordance with supplied strategies and policies.
\item \textbf{Behaviours}
\end{itemize}

\section{Design}
\begin{itemize}
\item Talk about what an OTP implementation overall consists of (in general)
\item Talk about our high-level design decisions
\item Talk about what design experiments we did (And explain why we went back on
  some of them)
\end{itemize}


We have decided to make our implementaion asynchronous,
\begin{itemize}
\item \textbf{Message sending}\\
  We have opted to statically type messages. This means that each actor can only
  receive messages of its data type, as well as ``System messages''. Message
  sending is accomplished using ``Mailboxes''. Using these actors can
  send the 2 kinds of messages to each other. There 3 kinds of mailboxes,
  unnamed, named and dynamic. Unnamed mailboxes are the main kind of mailbox,
  which allows the actors to send system messages and data messages to each
  other. Should the receiving actor crash, trying to send a message to it, using
  an unnamed mailbox, will result in an error. Named mailboxes are an
  indirection over unnamed mailboxes, used for sending messages to an actor that
  is registered globally with a name. These 2 first kind of mailboxes are typed
  over the message type. The dynamic mailbox is mainly used in situations where
  multiple different actor types can occur. % TODO: Add example (which children)
  It can only be used for sending system messages, until the user tries to casts
  it to a concrete type. This allows the user to handle them without caring
  about the underlying message type.
\item \textbf{Supervisor - Specification}

\item \textbf{Supervisor - Interaction}
\item \textbf{Behaviours}
  The concept of behavious are implemented as traits, that should be implemented
  in order to fulfill the behaviour. This will consist of a number of methods
  that should be implemented, and they (the traits) will often over a type. They
  will often often with a helper methods that provides the common boiler plate
  functionality. When a message passed the the actor is not part of the boiler
  plate, the behaviour will pass this message unto implementation of the trait.
\item \textbf{Asynchronous exceptions} % TODO: Make name better
  Unlike in Erlang, actors can't kill each other directly. Instead each
  actors can request that an other actors shuts itself down. The handeling of
  this message will then take place in library code, to avoid usercode from
  simply ignoring the request.
\end{itemize}

\section{Implementation}
\begin{itemize}
\item Talk about some concrete implementation decisions (and what drove them)
\item Go into some (few) low-level technical details that might be interesting
\end{itemize}

\section{Examples}
\begin{itemize}
\item High-level architecture (with nice diagrams \texttt{:)})
\item Motivation, i.e. what does this example demonstrate
\item What does this example show/what can we observe/conclude from it
\end{itemize}

\section{Evaluation}
\begin{itemize}
\item What does idiomatic Rust look like? (2 parts, the implementation of OTP
  and the usage of our library)
\item How expressive is the library?
\item How easy is it to implement common patterns, in terms of ergonomics (code
  length, complexity, etc)?
\item How easy is it to understand written code?
\end{itemize}

\section{Conclusion}

\end{document}

\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage[margin=2.5cm]{geometry}
\usepackage{listings}

\title{OTP in Rust}
\author{Andreas Nicolaisen - \texttt{jtc313} \\ Marco Aslak Persson - \texttt{bfr555}}
\date{\today}

\begin{document}

% TODO: Actors vs. processes

\maketitle

\section{Introduction}

\section{Background \& Analysis}
\textit{What's OTP?}
\begin{itemize}
\item What is the actor model
\item What is the goal of OTP?
\item What are the ``design principles'' of OTP?
\item How is it used?
\end{itemize}

\textit{How does this interact with Erlang}
\begin{itemize}
\item What parts of Erlang/BEAM is ``needed'' for implementing OTP? (processes,
  traps, mailboxes \& etc.)
\end{itemize}

\textit{Will probably have a similar structure to the Suture blog-post}
\begin{itemize}
\item What parts of OTP are we interested in porting.
\item How does this translate to Rust?
\item What does Rust make easier/harder?
\item What different things could an implementation focus on?
  \textit{Like performance, robustness, idiomaticity, expressiveness, ergonomics}.

  We'll try to find out whether it \textit{can} be done idiomaticly and ergonomically.

\item What have we chosen to focus on?
\end{itemize}

An implementation of an OTP-alike library will have to contain functionality in the lines of:
\begin{itemize}
\item \textbf{Message sending}\\
  The different actors should be able to communicate with each others, using
  messages. To accomplish this, they will need some way to refer to each other.
  This could be done by using global ids, registered names or passing around
  references to each other.
\item \textbf{Supervisor trees}\\
  In order to organize the program, the actors should be organized into
  supervisor trees. These will be trees of supervisor actors, with worker actors
  as leafes. The supervisors should be able to monitor and restart its children,
  should they crash, in accordance with supplied strategies and policies.
\item \textbf{Behaviours}
\end{itemize}

% TODO: Talk about local and global naming

\section{Design}
\begin{itemize}
\item Talk about what an OTP implementation overall consists of (in general)
\item Talk about our high-level design decisions
\item Talk about what design experiments we did (And explain why we went back on
  some of them)
\end{itemize}

We've designed our library to be implemented with an asynchronous execution model.
This is because any pratical implementation of an actor model requires actors to
be able to send messages asynchronously. It is not necessarily a requirement for
actors to run concurrently. By making our library asynchronous we enable the
implementation to take advantage of cooperative multi-threading via
``green threads'', which can both work in single-threaded and multi-threaded
contexts. Green threads are also a more light-weight alternative to using
operating system threads, which is important because idiomatic use of the actor
model involves creating actors for even small tasks. If creating an actor
required starting an operating system thread, then the overhead would quite
signficant compared to green threads.

% What is actor?
Actors in our library are realized as isolated computations % ?: Word choice
which receive and acts upon messages sent to them through their mailboxes.

Mailboxes are objects that enables the sending of messages to an actor, and are
comparable to PIDs in Erlang. We've opted to not hide mailboxes behind an
indirection like a PID and instead make actors use and store the data-structure
required for the actual sending of message directly. This is done to avoid
having to do extra book-keeping (like maintaining a --- possibly global --- map
of PID to the data-structure required for sending message). This is at the cost
of having to possibly store more data per mailbox compared to PID and having to
clone the mailbox whenever it needs to be sent to another actor (which is
required due to Rust's ownership system).

All actors can receive two kinds of messages. The first being system messages
which pertain to system-level concerns.
Currently this only involves requesting an actor to shut down, but other general
functionality like requesting a notification upon the actor shutting down could
also fall under system messages. In addition to system messages, actors can also
receive messages of their own specific message type. The message type of an
actor is specified as part of the actor's implementation. The only requirement for an
actor's message type is that is it transferable between threads, i.e. it
implements/satisfies the \texttt{Send} trait in Rust. This requirement allows
actors to run on seperate threads. Though by only having this requirement we do
not have the required invariants to allow for inter-process or remote
communication between actors, since that would require that messages were also
serializable.

Actors are responsible for acting upon the messages they receive. This is mainly
inteded to be done through behaivors which in our library is the equivalent
concept as in OTP. In our library behaivors are realized as different traits
with methods for the user to implement their own business
logic and usually a helper function for starting actors implementing that behaivor.
% TODO: Introduce behaivors from Erlang in Background

\begin{itemize}
\item \textbf{Message sending}\\
  We have opted to statically type messages. This means that each actor can only
  receive messages of its data type, as well as ``System messages''. Message
  sending is accomplished using ``Mailboxes''. Using these actors can
  send the 2 kinds of messages to each other. There 3 kinds of mailboxes,
  unnamed, named and dynamic. Unnamed mailboxes are the main kind of mailbox,
  which allows the actors to send system messages and data messages to each
  other. Should the receiving actor crash, trying to send a message to it, using
  an unnamed mailbox, will result in an error. Named mailboxes are an
  indirection over unnamed mailboxes, used for sending messages to an actor that
  is registered globally with a name. These 2 first kind of mailboxes are typed
  over the message type. The dynamic mailbox is mainly used in situations where
  multiple different actor types can occur. % TODO: Add example (which children)
  It can only be used for sending system messages, until the user tries to casts
  it to a concrete type. This allows the user to handle them without caring
  about the underlying message type.
\item \textbf{Actor naming}
  There are 2 forms of naming of actors, global and local. An actor's mailbox
  can be registered to a global name, then, through name-resolution, any actor
  can resolve the mailbox to that name. This useful for commucating with often
  used actors, without having to acquire its mailbox through other mean. Local
  naming is used when supervisors has to refer to its children. When actors are
  globally named, the name will be used locally as well. Not all actors have to
  be explicitly named, and when they're not they are given a unique local name.
\item \textbf{Supervision}
  Our design of supervision breaks into two parts, how the user specifies it and
  how they interact with it. We have chosen to use a declarative approch when
  specifying how supervision should be created, in order to aliviate the user
  from having to think about how supervision trees are built. Instead, they only
  have to think about how they want to structure their supervion
  tree/application. We allow the user to interact with the supervisors through
  messages, so that they can establish contact between actors dynamically. This
  is useful for dealing with dynamic instantiaion of actors, and for discovering
  other actors in the supervision tree, without having to resort to global
  naming.
  \begin{itemize}
  \item \textbf{Supervisor - Specification}
    In order to make it easier for the user, supervision trees can be created
    declaretivly, using a specication api. This consist of building blocks of
    supervisors and workers, which are put into a tree.
    % TODO: Insert example (diagram and code example)
    A supervisor will need some restart strategy, as well as vector of child
    specications. A worker will need some restart policy, and also takes an
    starting argument. Both supervisors and workers can be named, either locally
    or globally. Local names are only used when interacting with the supervisors
    of the named actor. % TODO: Add reasoning
  \item \textbf{Supervisor - Interaction}
    When interacting with a supervisor, it is important to note that supervisors
    themselves are actors, just like workers. This means that they can receive
    messages like any other actor. They can receive system messages asking them to
    shutdown, as well as requests. These requests allow other actors to ask for a
    list of the supervisors children, and to ask the supervisor to start another
    child, given a specification. All children are given a mailbox to their
    supervisor, so that they can make these requests of them.
  \end{itemize}
\item \textbf{Behaviours}
  The concept of behavious are implemented as traits, that should be implemented
  in order to fulfill the behaviour. This will consist of a number of methods
  that should be implemented, and they (the traits) will often over a type. They
  will often often with a helper methods that provides the common boiler plate
  functionality. When a message passed the the actor is not part of the boiler
  plate, the behaviour will pass this message unto implementation of the trait.
\item \textbf{Asynchronous exceptions} % TODO: Make name better
  Unlike in Erlang, actors can't kill each other directly. Instead each
  actors can request that an other actors shuts itself down. The handeling of
  this message will then take place in library code, to avoid usercode from
  simply ignoring the request.
\end{itemize}

\section{Implementation}
\begin{itemize}
\item Talk about some concrete implementation decisions (and what drove them)
\item Go into some (few) low-level technical details that might be interesting
\item Tokio, lightweight multiprocessing, like erlang.
\end{itemize}

\section{Examples}
\begin{itemize}
\item High-level architecture (with nice diagrams \texttt{:)})
\item Motivation, i.e. what does this example demonstrate
\item What does this example show/what can we observe/conclude from it
\end{itemize}

\section{Evaluation}
\begin{itemize}
\item What does idiomatic Rust look like? (2 parts, the implementation of OTP
  and the usage of our library)
\item How expressive is the library?
\item How easy is it to implement common patterns, in terms of ergonomics (code
  length, complexity, etc)?
\item How easy is it to understand written code?
\end{itemize}

\section{Conclusion}

\end{document}

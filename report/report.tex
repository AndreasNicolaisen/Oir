\documentclass[a4paper]{article}

\usepackage{amsmath}
\usepackage[margin=2.5cm]{geometry}
\usepackage{listings}

\title{OTP in Rust}
\author{Andreas Nicolaisen - \texttt{jtc313} \\ Marco Aslak Persson - \texttt{bfr555}}
\date{\today}

\begin{document}

% TODO: Actors vs. processes

\maketitle

\section{Introduction}

\section{Background \& Analysis}
\textit{What's OTP?}
\begin{itemize}
\item What is the actor model
\item What is the goal of OTP?
\item What are the ``design principles'' of OTP?
\item How is it used?
\end{itemize}

\textit{How does this interact with Erlang}
\begin{itemize}
\item What parts of Erlang/BEAM is ``needed'' for implementing OTP? (processes,
  traps, mailboxes \& etc.)
\end{itemize}

\textit{Will probably have a similar structure to the Suture blog-post}
\begin{itemize}
\item What parts of OTP are we interested in porting.
\item How does this translate to Rust?
\item What does Rust make easier/harder?
\item What different things could an implementation focus on?
  \textit{Like performance, robustness, idiomaticity, expressiveness, ergonomics}.

  We'll try to find out whether it \textit{can} be done idiomaticly and ergonomically.

\item What have we chosen to focus on?
\end{itemize}

An implementation of an OTP-alike library will have to contain functionality in the lines of:
\begin{itemize}
\item \textbf{Message sending}\\
  The different actors should be able to communicate with each others, using
  messages. To accomplish this, they will need some way to refer to each other.
  This could be done by using global ids, registered names or passing around
  references to each other.
\item \textbf{Supervisor trees}\\
  In order to organize the program, the actors should be organized into
  supervisor trees. These will be trees of supervisor actors, with worker actors
  as leafes. The supervisors should be able to monitor and restart its children,
  should they crash, in accordance with supplied strategies and policies.
\item \textbf{Behaviours}
\end{itemize}

% TODO: Talk about local and global naming

\section{Design}
%% \begin{itemize}
%% \item Talk about what an OTP implementation overall consists of (in general)
%% \item Talk about our high-level design decisions
%% \item Talk about what design experiments we did (And explain why we went back on
%%   some of them)
%% \end{itemize}

We've designed our library to be implemented with an asynchronous execution model.
This is because any pratical implementation of an actor model requires actors to
be able to send messages asynchronously. It is not necessarily a requirement for
actors to run concurrently. By making our library asynchronous we enable the
implementation to take advantage of cooperative multi-threading via
``green threads'', which can both work in single-threaded and multi-threaded
contexts. Green threads are a more light-weight alternative to using
operating system threads, which is important because idiomatic use of the actor
model often involves creating actors for even small tasks. If creating an actor
required starting an operating system thread, then the overhead would be quite
signficant compared to green threads.\\

% What is actor?
\noindent
Actors in our library are realized as isolated computations % ?: Word choice
which receive and acts upon messages sent to them through their mailboxes.\\

\noindent
Mailboxes are objects that enables the sending of messages to an actor, and are
comparable to PIDs in Erlang. We've opted to not hide mailboxes behind an
indirection like a PID and instead make actors use and store the data-structure
required for the actual sending of message directly. This is done to avoid
having to do extra book-keeping (like maintaining a --- possibly global --- map
of PID to the data-structure required for sending message). This is at the cost
of having to possibly store more data per mailbox compared to PID and having to
clone the mailbox whenever it needs to be sent to another actor (which is
required due to Rust's ownership system).\\

\noindent
All actors can receive two kinds of messages. The first being system messages
which pertain to system-level concerns, currently this only involves requesting
an actor to shut down. In addition to system messages, actors can also
receive messages of their own specific message type. The message type of an
actor is specified as part of the actor's implementation. The only requirement
for an actor's message type is that is it transferable between threads, i.e. it
implements/satisfies the \texttt{Send} trait in Rust. This requirement allows
actors to run on seperate threads. Though by only having this requirement we do
not have the required invariants to allow for inter-process or remote
communication between actors, since that would require that messages were also
serializable. The reason we choose to have the system messages as a seperate
thing, is to make it easier to deal with actors of different types, in contexts
where their type is irrelevant (such as in the supervisor implementaiton). In
hindsight, this is properly an unnecesarry complication, since all messages
could be wrapped in an some sort of \texttt{Either<SystemMessage, MessageType>},
or \texttt{SystemMessage} could have another variant containing the actors
message type. This would require more conversion in the background, but from the
users perspective, it should properly be easier to use, and we wouldn't have to
store/use two channels for each mailbox. On the other hand, having the two kinds
of messages in seperate channels, makes it easier to prioritise system message,
without having to go through all pending messages.\\

\noindent
Actors are responsible for acting upon the messages they receive. This is mainly
inteded to be done through behaivors which in our library is the equivalent
concept as in OTP. In our library behaivors are realized as different traits
with methods for the user to implement their own business logic and usually a
helper function for starting actors implementing that behaivor.\\
% TODO: Introduce behaivors from Erlang in Background

\noindent
Given this context, we will explain our design of different parts, in more
specific terms:
\begin{itemize}
\item \textbf{Mailboxes}\\
  %% We have opted to statically type messages. This means that each actor can only
  %% receive messages of its data type, as well as ``System messages''. Message
  %% sending is accomplished using ``Mailboxes''. Using these actors can
  %% send the 2 kinds of messages to each other. 
  There 3 kinds of mailboxes, unnamed, named and dynamic. Unnamed mailboxes are
  the main kind of mailbox, which allows the actors to send system messages and
  data messages to each other. Should the receiving actor crash, trying to send
  a message to it, using an unnamed mailbox, will result in an error. Named
  mailboxes are an indirection over unnamed mailboxes, used for sending messages
  to an actor that is registered globally with a name. These 2 first kind of
  mailboxes are typed over the message type. The dynamic mailbox is mainly used
  in situations where multiple different actor types can occur. % TODO: Add example (which children)
  It can only be used for sending system messages, until the user tries to casts
  it to a concrete type. This allows the user to handle them without caring
  about the underlying message type.
\item \textbf{Actor naming}\\
  There are two forms of naming of actors, global and local, both before the
  child was started. The names are used for two different purposes, for
  differenting between actors locally, and for aquiring a reference to an actor.
  An actor can ask a supervirsor (usually its own) for a list of its children.
  The supervisor then replies with a list of its' children, consisting of the
  child's name, and the child's mailbox. These names will be the names that
  where given before the child was started (either global or local). If a child
  is not given a name, it will be assigned one by its supervisor. If a child is
  globally named, it will additonally have its mailbox globally registered by
  its supervisor on startup. This global registration is useful for commucating
  with often used actors, without having to acquire a reference to its mailbox
  through other means. 
\item \textbf{Supervision}\\
  Our design of supervision breaks into two parts, how the user specifies it and
  how they interact with it. We have chosen to use a declarative approch when
  specifying how supervision should be created, in order to aliviate the user
  from having to think about how supervision trees are built. Instead, they only
  have to think about how they want to structure their supervion
  tree/application. We allow the user to interact with the supervisors through
  messages, so that they can establish contact between actors dynamically. This
  is useful for dealing with dynamic instantiaion of actors, and for discovering
  other actors in the supervision tree, without having to resort to global
  naming.
  \begin{itemize}
  \item \textbf{Supervisor - Specification}\\
    In order to make it easier for the user, supervision trees can be created
    declaretivly, using a specification api. This consist of building blocks of
    supervisors and workers, which are put into a tree.
    % TODO: Insert example (diagram and code example)
    A supervisor will need some restart strategy, as well as list of child
    specications. A worker will need some restart policy, and also takes an
    starting argument. Both supervisors and workers can be named, either locally
    or globally.
  \item \textbf{Supervisor - Interaction}\\
    When interacting with a supervisor, it is important to note that supervisors
    themselves are actors, just like workers. This means that they can receive
    messages like any other actor. They can receive system messages asking them to
    shutdown, as well as requests. These requests allow other actors to ask for a
    list of the supervisors children, and to ask the supervisor to start another
    child, given a specification. All children are given a mailbox to their
    supervisor, so that they can make these requests of them.
  \end{itemize}
\item \textbf{Behaviours}\\
  The concept of behavious from OTP are implemented as traits, that should be
  implemented in order to fulfill the behaviour. This will consist of a number
  of methods that should be implemented, and they (the traits) will often be
  over a type. They will often come with a helper method that provides the
  common boiler plate functionality (eg. the handeling of system messages). When
  a message passed the the actor is not part of the boiler plate, the behaviour
  will pass this message onto implementation of the trait.
\item \textbf{Asynchronous exceptions}\\ % TODO: Make name better
  Unlike in Erlang, actors can't kill each other directly. Instead each
  actors can request that an other actors shuts itself down. The handeling of
  this message will then take place in library code, to avoid usercode from
  simply ignoring the request. Since the messages are handled sequentially this
  means that actors cannot be shut down when they are handeling another
  messages. This has the advantage of avoiding actors being shutdown in crital
  sections, but has the disadvantage of not being able to shutdown an actor that
  is stuck. This is the only practical way of shutting down an actor, since it
  is not possible to stop a scheduled task. One way shutting down a running
  actor \textit{could} be done, it to have each actor be its own seperate OS
  thread, which you could then ask the OS to shutdown. The comes with the
  downside mentioned earlier, of not being able to take advantage of ``green
  threads''.
\end{itemize}

\section{Implementation}
\begin{itemize}
\item Talk about some concrete implementation decisions (and what drove them)
\item Go into some (few) low-level technical details that might be interesting
\item Tokio, lightweight multiprocessing, like erlang.
\end{itemize}

\section{Examples}
\begin{itemize}
\item High-level architecture (with nice diagrams \texttt{:)})
\item Motivation, i.e. what does this example demonstrate
\item What does this example show/what can we observe/conclude from it
\end{itemize}

\section{Evaluation}
\begin{itemize}
\item What does idiomatic Rust look like? (2 parts, the implementation of OTP
  and the usage of our library)
\item How expressive is the library?
\item How easy is it to implement common patterns, in terms of ergonomics (code
  length, complexity, etc)?
\item How easy is it to understand written code?
\end{itemize}

\section{Conclusion}

\end{document}
